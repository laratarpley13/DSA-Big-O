/*
1. What is the Big O for this?
    (a.) Constant time, O(1), because don't have to sort through every person.
    (b.) Linear time, O(n), because going down the list one at a time.

2. Even or odd
    Constant time, O(1), because it only take one iteration every time to calculate.

3. Are you here?
    Polynomial time, O(n^2), because it requires 2 levels of looping through the list.

4. Doubler
    Linear time, O(n), because it only needs to iterate down the list,
    so the final time just depends on the length of the array.

5. Naive search
    Linear time, O(n), beacause it only needs to iterate down the list,
    so the final time just depends on the length of the array.

6. Creating pairs:
    Polynomial time, O(n^2), because it requires 2 levels of looping through the list.

7. Compute the sequence
    Linear time, O(n), because it only needs to iterate down the list, 
    so the final time just depends on the length of the array.

8. An efficient search
    Logartithmic time, O(log(n)), cuts the problem size in half each round through.

9. Random element
    Constant time, O(1), because it only take one iteration every time to calculate.

10. What Am I?
    Linear time, O(n), because it only needs to iterate down the list,
    so the final time just depends on the lenght of the array.

11. Tower of Hanoi

12. Iterative version
    Requires a lot of for looping, therefore, a much longer runtime,
    especially as the size of the inputs increases

13. Recursive Big O
    Should all be shorter run times than when solving iteratively

14. Iterative Big O
    Will require multiple for loops, therefore increasing their run time
*/